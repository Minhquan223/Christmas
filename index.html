
<<<<<<< HEAD
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Happy Christmas</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Great+Vibes&family=Montserrat:wght@300;500&display=swap&subset=vietnamese" rel="stylesheet">

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background-color: #050510; 
            font-family: 'Montserrat', sans-serif;
            touch-action: none; 
        }
        
        #canvas-container {
            position: fixed; top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 1;
        }

        #text-layer {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none; 
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            text-align: center; color: #fff;
        }

        .noise-overlay {
            position: fixed; top: 0; left: 0;
            width: 100vw; height: 100vh;
            opacity: 0.07;
            background: url('https://grainy-gradients.vercel.app/noise.svg');
            z-index: 5; pointer-events: none;
        }

        .vignette {
            position: fixed; top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: radial-gradient(circle, transparent 50%, rgba(0,0,0,0.8) 150%);
            z-index: 6; pointer-events: none;
        }

        .text-container {
            position: absolute;
            width: 90%; max-width: 800px; padding: 20px;
            border-radius: 20px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 40px rgba(0,0,0,0.5);
            opacity: 0; visibility: hidden;
        }

        .main-title {
            font-family: 'Great Vibes', cursive;
            font-size: clamp(3rem, 10vw, 5rem); 
            color: #ff9de9; 
            text-shadow: 0 0 20px rgba(255, 157, 233, 0.8);
            margin-bottom: 15px;
            line-height: 1.2;
        }

        .subtitle {
            font-family: 'Cormorant Garamond', serif;
            font-size: clamp(1rem, 4vw, 1.5rem);
            letter-spacing: 2px;
            line-height: 1.5;
            color: #e0e0ff;
        }

        /* MEMORY CARD STYLE */
        .memory-card {
            position: fixed;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.8); 
            transform-origin: bottom right; 
            
            opacity: 0; visibility: hidden;
            padding: 10px;
            background: rgba(255, 255, 255, 0.15);
            backdrop-filter: blur(15px);
            -webkit-backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.3);
            border-radius: 12px;
            box-shadow: 0 0 30px rgba(255, 105, 180, 0.4);
            z-index: 100;
            pointer-events: auto; 
            transition: border-color 0.3s, box-shadow 0.3s; /* Chỉ transition style, vị trí do GSAP lo */
        }

        .memory-card.minimized {
            cursor: pointer;
            box-shadow: 0 0 15px rgba(255, 105, 180, 0.8);
            border-color: rgba(255, 255, 255, 0.6);
        }
        
        /* Hiệu ứng hover nhẹ khi ở trạng thái nhỏ để người dùng biết bấm được */
        .memory-card.minimized:hover {
            transform: scale(0.38); 
        }

        .memory-card img {
            max-width: 100%;
            width: 300px; 
            height: auto;
            border-radius: 8px; display: block;
        }

        @media (max-width: 600px) {
            .memory-card img {
                width: 75vw; 
            }
        }

        .memory-note {
            margin-top: 10px; font-size: 0.9rem;
            color: #ffccf2; font-family: 'Cinzel', serif;
            text-align: center;
            transition: opacity 0.5s;
        }

        #loader {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%; background: #000;
            z-index: 200; display: flex;
            justify-content: center; align-items: center;
            color: #ff9de9; font-family: 'Cinzel', serif;
            transition: opacity 1s;
        }
    </style>
</head>
<body>

    <div id="loader">LOADING MEMORIES...</div>
    <div class="noise-overlay"></div>
    <div class="vignette"></div>

    <div id="text-layer">
        <div class="text-container" id="scene-1">
            <h1 class="main-title">Merry Christmas</h1>
            <p class="subtitle">Chúc người anh yêu một mùa giáng sinh ấm áp</p>
        </div>
        <div class="text-container" id="scene-2">
            <p class="subtitle" style="font-size: clamp(1.2rem, 5vw, 1.8rem);">
                Dù em có đang bận rộn theo đuổi ước mơ...
            </p>
        </div>
        <div class="text-container" id="scene-3">
            <h1 class="main-title">Vẫn mãi bên nhau em nhớ </h1>
            <p class="subtitle">Anh yêu Bé nhiều lắm Thùy Linh ❤️</p>
        </div>
    </div>

    <div class="memory-card" id="memory-card">
        <img src="https://images.unsplash.com/photo-1516641396056-0ce60a85d49f?q=80&w=2070&auto=format&fit=crop" alt="Memory">
        <div class="memory-note" id="memory-note">24.12.2025 - Our Winter</div>
    </div>

    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        // --- 1. SETUP & THREE.JS LOGIC (Giữ nguyên) ---
        const isMobile = window.innerWidth < 768;
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050510, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        if(isMobile) { camera.position.set(0, 6, 22); } 
        else { camera.position.set(0, 5, 15); }

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        const renderScene = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.5, 0.4, 0.85 
        );
        bloomPass.threshold = 0;
        bloomPass.strength = isMobile ? 1.2 : 1.5;
        bloomPass.radius = 0.5;

        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 32, 32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        const particleTexture = createParticleTexture();

        const treeGroup = new THREE.Group();
        scene.add(treeGroup);
        const particleCount = isMobile ? 1500 : 2500;
        const geometry = new THREE.BufferGeometry();
        const positions = []; const colors = []; const sizes = [];
        const colorInside = new THREE.Color('#ff0080'); 
        const colorOutside = new THREE.Color('#ffb3e6'); 

        for (let i = 0; i < particleCount; i++) {
            const angle = i * 0.15; 
            const radius = 5 * (1 - i / particleCount); 
            const y = (i / particleCount) * 12 - 6; 
            const x = Math.cos(angle) * radius + (Math.random()-0.5)*0.5;
            const z = Math.sin(angle) * radius + (Math.random()-0.5)*0.5;
            positions.push(x, y + (Math.random()-0.5)*0.5, z);
            const mixedColor = colorInside.clone().lerp(colorOutside, Math.random());
            colors.push(mixedColor.r, mixedColor.g, mixedColor.b);
            sizes.push(Math.random() * 2);
        }
        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

        const material = new THREE.PointsMaterial({
            size: 0.2, vertexColors: true, map: particleTexture,
            blending: THREE.AdditiveBlending, depthWrite: false, transparent: true, opacity: 0.8
        });
        const tree = new THREE.Points(geometry, material);
        treeGroup.add(tree);

        const groundGeo = new THREE.BufferGeometry();
        const groundPos = [];
        const groundCount = isMobile ? 500 : 1000;
        for(let i=0; i<groundCount; i++) {
            const r = Math.random() * 15; 
            const theta = Math.random() * Math.PI * 2;
            groundPos.push(r * Math.cos(theta), -6 + (Math.random()-0.5)*0.5, r * Math.sin(theta));
        }
        groundGeo.setAttribute('position', new THREE.Float32BufferAttribute(groundPos, 3));
        const groundMat = new THREE.PointsMaterial({
            color: 0xffffff, size: 0.15, map: particleTexture,
            transparent: true, opacity: 0.5, blending: THREE.AdditiveBlending, depthWrite: false
        });
        scene.add(new THREE.Points(groundGeo, groundMat));

        const starGeo = new THREE.SphereGeometry(0.3, 16, 16);
        const star = new THREE.Mesh(starGeo, new THREE.MeshBasicMaterial({ color: 0xffffff }));
        star.position.set(0, 6.2, 0);
        treeGroup.add(star);
        const starGlow = new THREE.Mesh(
            new THREE.PlaneGeometry(3, 3),
            new THREE.MeshBasicMaterial({
                map: particleTexture, color: 0xffddff, transparent: true, opacity: 0.4,
                blending: THREE.AdditiveBlending, side: THREE.DoubleSide
            })
        );
        starGlow.position.set(0, 6.2, 0);
        treeGroup.add(starGlow);

        const snowCount = isMobile ? 500 : 1000;
        const snowGeo = new THREE.BufferGeometry();
        const snowPos = [];
        for(let i=0; i<snowCount; i++) {
            snowPos.push((Math.random()-0.5)*40, (Math.random()-0.5)*40, (Math.random()-0.5)*40);
        }
        snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(snowPos, 3));
        const snowSystem = new THREE.Points(snowGeo, new THREE.PointsMaterial({
            color: 0xffffff, size: 0.15, map: particleTexture, transparent: true, opacity: 0.6, depthWrite: false
        }));
        scene.add(snowSystem);

        const clock = new THREE.Clock();
        let mouseX = 0; let mouseY = 0;
        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth) - 0.5;
            mouseY = (e.clientY / window.innerHeight) - 0.5;
        });
        document.addEventListener('touchmove', (e) => {
            const touch = e.touches[0];
            mouseX = (touch.clientX / window.innerWidth) - 0.5;
            mouseY = (touch.clientY / window.innerHeight) - 0.5;
        }, { passive: true });

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();
            treeGroup.rotation.y = elapsedTime * 0.15; 
            const scale = 1 + Math.sin(elapsedTime * 2) * 0.02;
            tree.scale.set(scale, scale, scale);
            starGlow.lookAt(camera.position);

            const snowPositions = snowSystem.geometry.attributes.position.array;
            for(let i = 1; i < snowPositions.length; i+=3) {
                snowPositions[i] -= 0.05; 
                if(snowPositions[i] < -20) snowPositions[i] = 20; 
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
            
            camera.position.x += (mouseX * 5 - camera.position.x) * 0.05;
            camera.position.y += (-mouseY * 2 + (isMobile ? 6 : 5) - camera.position.y) * 0.05;
            camera.lookAt(0, 0, 0);

            composer.render();
        }

        // --- 5. LOGIC KỂ CHUYỆN & TƯƠNG TÁC (Đã sửa lại) ---
        
        let storyTimeline; // Biến toàn cục để quản lý timeline

        function startStory() {
            // 1. Nếu đang có timeline chạy dở thì hủy nó
            if (storyTimeline) storyTimeline.kill();

            // 2. RESET TRẠNG THÁI (Quan trọng): Đưa mọi thứ về vị trí ban đầu
            // Ẩn toàn bộ text
            gsap.set(".text-container", { autoAlpha: 0, scale: 0.9, y: 0, filter: "blur(0px)" });
            
            // Đưa Memory Card về giữa màn hình và ẩn đi
            const card = document.getElementById('memory-card');
            const note = document.getElementById('memory-note');
            card.classList.remove('minimized'); // Xóa class nhỏ
            
            gsap.set("#memory-card", {
                autoAlpha: 0, 
                scale: 0.8,
                top: "50%", left: "50%", 
                right: "auto", bottom: "auto", // Reset vị trí góc
                xPercent: -50, yPercent: -50 // Căn giữa
            });
            gsap.set("#memory-note", { opacity: 1 }); // Hiện lại note

            // 3. TẠO TIMELINE MỚI
            storyTimeline = gsap.timeline();

            // Scene 1
            storyTimeline.to("#scene-1", { autoAlpha: 1, scale: 1, duration: 1.5 })
                         .to("#scene-1", { autoAlpha: 0, scale: 1.1, filter: "blur(10px)", duration: 1.5, delay: 2.5 });

            // Scene 2
            storyTimeline.to("#scene-2", { autoAlpha: 1, scale: 1, duration: 1.5 })
                         .to("#scene-2", { autoAlpha: 0, y: -20, filter: "blur(10px)", duration: 1.5, delay: 2.5 });

            // Scene 3
            storyTimeline.to("#scene-3", { autoAlpha: 1, scale: 1, duration: 1.5 })
                         .to("#scene-3", { autoAlpha: 0, duration: 1, delay: 2.5 }) 
            
            // Hiện ảnh ở giữa màn hình
                         .to("#memory-card", { 
                             autoAlpha: 1, 
                             scale: 1, 
                             duration: 1.5, 
                             ease: "power2.out" 
                         })
              
            // Đợi 3s ngắm ảnh rồi thu nhỏ về góc phải
                         .add(() => {
                             gsap.to("#memory-card", {
                                 top: "auto",      
                                 bottom: "30px",   
                                 left: "auto",     
                                 right: "20px",    
                                 xPercent: 0,      
                                 yPercent: 0,      
                                 scale: 0.35,      
                                 duration: 2,
                                 ease: "power2.inOut",
                                 onComplete: () => {
                                     card.classList.add('minimized');
                                     gsap.to(note, { opacity: 0, duration: 0.5 });
                                 }
                             });
                         }, "+=3");
        }

        // --- SỰ KIỆN CLICK ---
        const cardElement = document.getElementById('memory-card');
        
        cardElement.addEventListener('click', () => {
            // Nếu card đang ở trạng thái thu nhỏ (đã chạy xong story)
            if (cardElement.classList.contains('minimized')) {
                // CHẠY LẠI CÂU CHUYỆN TỪ ĐẦU
                startStory();
            }
        });

        // --- KHỞI CHẠY ---
        window.onload = () => {
            const loader = document.getElementById('loader');
            loader.style.opacity = '0';
            setTimeout(() => {
                loader.style.display = 'none';
                animate();
                startStory();
            }, 1000);
        };

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
<!-- Code injected by live-server -->
<script>
	// <![CDATA[  <-- For SVG support
	if ('WebSocket' in window) {
		(function () {
			function refreshCSS() {
				var sheets = [].slice.call(document.getElementsByTagName("link"));
				var head = document.getElementsByTagName("head")[0];
				for (var i = 0; i < sheets.length; ++i) {
					var elem = sheets[i];
					var parent = elem.parentElement || head;
					parent.removeChild(elem);
					var rel = elem.rel;
					if (elem.href && typeof rel != "string" || rel.length == 0 || rel.toLowerCase() == "stylesheet") {
						var url = elem.href.replace(/(&|\?)_cacheOverride=\d+/, '');
						elem.href = url + (url.indexOf('?') >= 0 ? '&' : '?') + '_cacheOverride=' + (new Date().valueOf());
					}
					parent.appendChild(elem);
				}
			}
			var protocol = window.location.protocol === 'http:' ? 'ws://' : 'wss://';
			var address = protocol + window.location.host + window.location.pathname + '/ws';
			var socket = new WebSocket(address);
			socket.onmessage = function (msg) {
				if (msg.data == 'reload') window.location.reload();
				else if (msg.data == 'refreshcss') refreshCSS();
			};
			if (sessionStorage && !sessionStorage.getItem('IsThisFirstTime_Log_From_LiveServer')) {
				console.log('Live reload enabled.');
				sessionStorage.setItem('IsThisFirstTime_Log_From_LiveServer', true);
			}
		})();
	}
	else {
		console.error('Upgrade your browser. This Browser is NOT supported WebSocket for Live-Reloading.');
	}
	// ]]>
</script>
</body>
</html>
=======
<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Magical Christmas | 3D Interactive Experience</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Great+Vibes&family=Montserrat:wght@300;500&display=swap&subset=vietnamese" rel="stylesheet">

    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { 
            overflow: hidden; 
            background-color: #050510; 
            font-family: 'Montserrat', sans-serif;
        }
        
        #canvas-container {
            position: fixed; top: 0; left: 0;
            width: 100vw; height: 100vh;
            z-index: 1;
        }

        #ui-layer {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none; 
            display: flex; flex-direction: column;
            justify-content: center; align-items: center;
            text-align: center; color: #fff;
        }

        .noise-overlay {
            position: fixed; top: 0; left: 0;
            width: 100vw; height: 100vh;
            opacity: 0.07;
            background: url('https://grainy-gradients.vercel.app/noise.svg');
            z-index: 5; pointer-events: none;
        }

        .vignette {
            position: fixed; top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: radial-gradient(circle, transparent 50%, rgba(0,0,0,0.8) 150%);
            z-index: 6; pointer-events: none;
        }

        .text-container {
            position: absolute;
            width: auto; max-width: 800px; padding: 40px;
            border-radius: 20px;
            background: rgba(0, 0, 0, 0.3);
            backdrop-filter: blur(8px);
            -webkit-backdrop-filter: blur(8px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            box-shadow: 0 0 40px rgba(0,0,0,0.5);
            opacity: 0; visibility: hidden;
        }

        .main-title {
            font-family: 'Great Vibes', cursive;
            font-size: clamp(3rem, 8vw, 6rem);
            color: #ff9de9; 
            text-shadow: 0 0 20px rgba(255, 157, 233, 0.8);
            margin-bottom: 20px;
        }

        .subtitle {
            font-family: 'Cormorant Garamond', serif;
            font-size: clamp(1rem, 3vw, 1.5rem);
            letter-spacing: 4px;
            line-height: 1.6;
            color: #e0e0ff;
        }

        .memory-card {
            position: absolute;
            opacity: 0; visibility: hidden;
            transform: scale(0.8);
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(15px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 12px;
            box-shadow: 0 0 50px rgba(255, 105, 180, 0.3);
            pointer-events: auto; 
        }

        .memory-card img {
            max-width: 300px; max-height: 400px;
            border-radius: 8px; display: block;
        }

        .memory-note {
            margin-top: 15px; font-size: 0.9rem;
            color: #ffccf2; font-family: 'Cinzel', serif;
        }

        .music-btn {
            position: fixed; bottom: 30px; right: 30px;
            z-index: 20; background: none;
            border: 1px solid rgba(255,255,255,0.3);
            color: white; padding: 10px 20px;
            border-radius: 30px; cursor: pointer;
            font-family: 'Montserrat', sans-serif; font-size: 0.8rem;
            transition: all 0.3s; pointer-events: auto;
        }
        .music-btn:hover { background: rgba(255,255,255,0.1); border-color: white; }

        #loader {
            position: fixed; top: 0; left: 0;
            width: 100%; height: 100%; background: #000;
            z-index: 100; display: flex;
            justify-content: center; align-items: center;
            color: #ff9de9; font-family: 'Cinzel', serif;
            transition: opacity 1s;
        }
    </style>
</head>
<body>

    <div id="loader">LOADING MEMORIES...</div>
    <div class="noise-overlay"></div>
    <div class="vignette"></div>

    <div id="ui-layer">
        <div class="text-container" id="scene-1">
            <h1 class="main-title">Merry Christmas</h1>
            <p class="subtitle">Chúc người anh yêu một mùa giáng sinh ấm áp</p>
        </div>
        <div class="text-container" id="scene-2">
            <p class="subtitle" style="font-size: 1.8rem; color: #fff;">
                "Dù em đang bận rộn theo đuổi ước mơ..."
            </p>
        </div>
        <div class="text-container" id="scene-3">
            <h1 class="main-title" style="font-size: 4rem;">Mãi bên nhau nhé</h1>
            <p class="subtitle">Yêu Bé nhiều lắm Thùy Linh</p>
        </div>
        <div class="memory-card" id="memory-card">
            <img src="https://images.unsplash.com/photo-1516641396056-0ce60a85d49f?q=80&w=2070&auto=format&fit=crop" alt="Memory">
            <div class="memory-note">24.12.2025 - Our Winter</div>
        </div>
    </div>

    <button class="music-btn" id="btn-play">♫ Replay Story</button>
    <div id="canvas-container"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/EffectComposer.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/RenderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/ShaderPass.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/CopyShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/shaders/LuminosityHighPassShader.js"></script>
    <script src="https://unpkg.com/three@0.128.0/examples/js/postprocessing/UnrealBloomPass.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>

    <script>
        // 1. SCENE SETUP
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050510, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 15); 

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        // 2. POST-PROCESSING (BLOOM EFFECT)
        const renderScene = new THREE.RenderPass(scene, camera);
        const bloomPass = new THREE.UnrealBloomPass(
            new THREE.Vector2(window.innerWidth, window.innerHeight),
            1.5, 0.4, 0.85 
        );
        bloomPass.threshold = 0;
        bloomPass.strength = 1.5; // GIẢM CHÓI: Giảm từ 2.0 xuống 1.5
        bloomPass.radius = 0.5;

        const composer = new THREE.EffectComposer(renderer);
        composer.addPass(renderScene);
        composer.addPass(bloomPass);

        // 3. TEXTURE GENERATOR 
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            const grad = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            grad.addColorStop(0, 'rgba(255, 255, 255, 1)');
            grad.addColorStop(1, 'rgba(255, 255, 255, 0)');
            ctx.fillStyle = grad;
            ctx.fillRect(0, 0, 32, 32);
            const texture = new THREE.Texture(canvas);
            texture.needsUpdate = true;
            return texture;
        }
        const particleTexture = createParticleTexture();

        // 4. CREATE THE CHRISTMAS TREE
        const treeGroup = new THREE.Group();
        scene.add(treeGroup);

        const particleCount = 2500;
        const geometry = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const sizes = [];

        const colorInside = new THREE.Color('#ff0080'); 
        const colorOutside = new THREE.Color('#ffb3e6'); 

        for (let i = 0; i < particleCount; i++) {
            const angle = i * 0.15; 
            const radius = 5 * (1 - i / particleCount); 
            const y = (i / particleCount) * 12 - 6; 
            
            const randomX = (Math.random() - 0.5) * 0.5;
            const randomZ = (Math.random() - 0.5) * 0.5;
            const randomY = (Math.random() - 0.5) * 0.5;

            const x = Math.cos(angle) * radius + randomX;
            const z = Math.sin(angle) * radius + randomZ;

            positions.push(x, y + randomY, z);

            const mixedColor = colorInside.clone().lerp(colorOutside, Math.random());
            colors.push(mixedColor.r, mixedColor.g, mixedColor.b);

            sizes.push(Math.random() * 2);
        }

        geometry.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geometry.setAttribute('size', new THREE.Float32BufferAttribute(sizes, 1));

        const material = new THREE.PointsMaterial({
            size: 0.2,
            vertexColors: true,
            map: particleTexture,
            blending: THREE.AdditiveBlending,
            depthWrite: false,
            transparent: true,
            opacity: 0.8
        });

        const tree = new THREE.Points(geometry, material);
        treeGroup.add(tree);

        // --- NEW FEATURE: NỀN ĐẤT HẠT TRẮNG (GROUND) ---
        const groundGeo = new THREE.BufferGeometry();
        const groundPos = [];
        const groundCount = 1000;
        for(let i=0; i<groundCount; i++) {
            // Tạo hạt rải rác trên mặt phẳng tròn
            const r = Math.random() * 15; // Bán kính nền đất
            const theta = Math.random() * Math.PI * 2;
            const x = r * Math.cos(theta);
            const z = r * Math.sin(theta);
            const y = -6 + (Math.random() - 0.5) * 0.5; // Gần gốc cây
            groundPos.push(x, y, z);
        }
        groundGeo.setAttribute('position', new THREE.Float32BufferAttribute(groundPos, 3));
        const groundMat = new THREE.PointsMaterial({
            color: 0xffffff, // Hạt màu trắng
            size: 0.15,
            map: particleTexture,
            transparent: true,
            opacity: 0.5,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });
        const groundSystem = new THREE.Points(groundGeo, groundMat);
        scene.add(groundSystem); // Thêm vào scene (không thêm vào treeGroup để không bị xoay)

        // Star on Top
        const starGeo = new THREE.SphereGeometry(0.3, 16, 16);
        const starMat = new THREE.MeshBasicMaterial({ color: 0xffffff });
        const star = new THREE.Mesh(starGeo, starMat);
        star.position.set(0, 6.2, 0);
        treeGroup.add(star);
        
        // GIẢM CHÓI STAR: Giảm opacity của quầng sáng
        const starGlowGeo = new THREE.PlaneGeometry(3, 3);
        const starGlowMat = new THREE.MeshBasicMaterial({
            map: particleTexture,
            color: 0xffddff,
            transparent: true,
            opacity: 0.4, // Giảm từ 0.5 -> 0.4 để bớt gắt
            blending: THREE.AdditiveBlending,
            side: THREE.DoubleSide
        });
        const starGlow = new THREE.Mesh(starGlowGeo, starGlowMat);
        starGlow.position.set(0, 6.2, 0);
        treeGroup.add(starGlow);

        // 5. SNOWFALL
        const snowCount = 1000;
        const snowGeo = new THREE.BufferGeometry();
        const snowPos = [];
        for(let i=0; i<snowCount; i++) {
            snowPos.push(
                (Math.random() - 0.5) * 40, 
                (Math.random() - 0.5) * 40, 
                (Math.random() - 0.5) * 40  
            );
        }
        snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(snowPos, 3));
        const snowMat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.15,
            map: particleTexture,
            transparent: true,
            opacity: 0.6,
            depthWrite: false
        });
        const snowSystem = new THREE.Points(snowGeo, snowMat);
        scene.add(snowSystem);

        // 6. ANIMATION LOOP
        const clock = new THREE.Clock();
        let mouseX = 0; let mouseY = 0;
        document.addEventListener('mousemove', (e) => {
            mouseX = (e.clientX / window.innerWidth) - 0.5;
            mouseY = (e.clientY / window.innerHeight) - 0.5;
        });

        function animate() {
            requestAnimationFrame(animate);
            const elapsedTime = clock.getElapsedTime();

            treeGroup.rotation.y = elapsedTime * 0.15; 
            const scale = 1 + Math.sin(elapsedTime * 2) * 0.02;
            tree.scale.set(scale, scale, scale);

            // Update Star lookAt logic
            starGlow.scale.setScalar(1 + Math.sin(elapsedTime * 3) * 0.2);
            starGlow.lookAt(camera.position);

            // Snow Animation
            const snowPositions = snowSystem.geometry.attributes.position.array;
            for(let i = 1; i < snowPositions.length; i+=3) {
                snowPositions[i] -= 0.05; 
                if(snowPositions[i] < -20) snowPositions[i] = 20; 
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
            snowSystem.rotation.y = Math.sin(elapsedTime * 0.2) * 0.2;

            // Camera Parallax
            camera.position.x += (mouseX * 5 - camera.position.x) * 0.05;
            camera.position.y += (-mouseY * 2 + 5 - camera.position.y) * 0.05;
            camera.lookAt(0, 0, 0);

            composer.render();
        }

        // 7. TIMELINE STORYTELLING (LOGIC ĐÃ SỬA)
        function startStory() {
            const tl = gsap.timeline();
            
            gsap.set("#ui-layer", { opacity: 1 });
            gsap.set(".text-container", { autoAlpha: 0, scale: 0.9 });
            gsap.set(".memory-card", { autoAlpha: 0, scale: 0.8 });

            // Scene 1
            tl.to("#scene-1", { autoAlpha: 1, scale: 1, duration: 1.5 })
              .to("#scene-1", { autoAlpha: 0, scale: 1.1, filter: "blur(10px)", duration: 1.5, delay: 3 });

            // Scene 2
            tl.to("#scene-2", { autoAlpha: 1, scale: 1, duration: 1.5 })
              .to("#scene-2", { autoAlpha: 0, y: -20, filter: "blur(10px)", duration: 1.5, delay: 3 });

            // Scene 3
            tl.to("#scene-3", { autoAlpha: 1, scale: 1, duration: 1.5 })
            // LOGIC MỚI: Tắt hẳn chữ Scene 3 trước khi hiện ảnh
              .to("#scene-3", { autoAlpha: 0, duration: 1, delay: 3 }) 
            
            // Hiện ảnh (Sau khi chữ đã tắt)
              .to("#memory-card", { 
                  autoAlpha: 1, 
                  scale: 1, 
                  duration: 1.5, 
                  ease: "power2.out" 
              })
            
            // Ảnh chỉ hiện 3s rồi tắt toàn bộ UI
              .to("#ui-layer", {
                  opacity: 0,
                  duration: 2,
                  ease: "power2.inOut",
                  delay: 3 // Delay 3s theo yêu cầu
              });
              
            // Camera Zoom
            gsap.to(camera.position, { z: 10, duration: 15, ease: "power1.inOut" });
        }

        window.onload = () => {
            const loader = document.getElementById('loader');
            loader.style.opacity = '0';
            setTimeout(() => {
                loader.style.display = 'none';
                animate();
                startStory();
            }, 1000);
        };

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });

        const btnPlay = document.getElementById('btn-play');
        btnPlay.addEventListener('click', () => {
            gsap.set("#ui-layer", { opacity: 1 });
            startStory();
        });

    </script>
<!-- Code injected by live-server -->
<script>
	// <![CDATA[  <-- F